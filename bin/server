#!/usr/bin/env node

const distbin = require('../');
const http = require('http');
const querystring = require('querystring')
const url = require('url')

// Run tests if this file is executed
if (require.main === module) {
  runServer()
    .then(() => process.exit())
    .catch((err) => {
    	console.error("Uncaught Error", err)
    	process.exit(1)
    })
}

async function runServer() {
	Object.keys({
	  'SIGINT': 2,
	  'SIGTERM': 15
	}).forEach(function (signal) {
	  process.on(signal, function () {
	  	process.exit()
	  });
	});

	const bin = distbin()

	// api (anonymous port)
	const apiServer = http.createServer(bin)
	let apiServerUrl = await new Promise((resolve) => {
		apiServer.listen(0, function (err) {
			resolve(`http://localhost:${apiServer.address().port}`)
		})
	})

	// html
	const htmlHandler = distbinHtml({ apiUrl: apiServerUrl })

	// mainServer delegates to htmlHandler or distbin api handler based on Accept header
	// of request
	// #TODO this is awkard. Really the 'home page module' at / should now how to content negotiate, not this
	const mainServer = http.createServer((req, res) => {
		// htmlHandler only supports '/' right now (#TODO)
		if (req.url === '/') {
			const accept = req.headers.accept ? req.headers.accept.split(',') : [];
			for (let mime of accept) {
				switch (mime) {
					case 'text/html':
						return htmlHandler(req, res);
					case 'application/json':
						return bin(req, res);
				}
			}
		}
		// accept header not present or didn't match, default to api ?
		// but maybe should be "Not Acceptable" status code
		return bin(req, res);
	})
	// listen
	let mainServerUrl = await new Promise((resolve) => {
		mainServer.listen(process.env.PORT || 0, (err) => {
			resolve(`http://localhost:${mainServer.address().port}`)
		})
	})

	console.log(mainServerUrl)
	// now just like listen
	await new Promise(function () {

	})
}

function distbinHtml({ apiUrl }) {
	return async function (req, res) {
		switch (req.method.toLowerCase()) {
			case 'get':
				res.writeHead(200)
				res.write(`
					<head>
						<style>
						html { font-size: 1.2vw; }
						body {
							margin: 0 auto;
							max-width: 60em;
						  padding: 1.5rem;
						}
						p {
						  line-height: 1.5rem;
						  margin-bottom: 1.5rem;
						}
						</style>
					</head>
					<h1>distbin</h1>
						<p>
							distbin is a <strong>dist</strong>ributed <a href="https://en.wikipedia.org/wiki/Pastebin">paste<strong>bin</strong></a>.
							i.e. it is a web service where anyone can post documents. What makes distbin unique is that it supports distributed social interactions around these documents using candidate web standards emerging from the <a href="https://www.w3.org/wiki/Socialwg">W3C Social Web Working Group</a>, for example the <a href="https://www.w3.org/TR/activitystreams-core/">Activity Streams</a> vocabulary and <a href="https://www.w3.org/TR/activitypub/">ActivityPub</a> protocol.
						</p>
						<p>
							Status: <strong>very</strong> much toy status right now. Activities are not persisted outside of process memory. No Authorization checks exist at all.
						</p>
					<h2>Feature Progress</h2>
						<ul>
							<li>ActivityPub - <a href="/activitypub">/activitypub</a>
								<ul>
									<li><a href="https://www.w3.org/TR/activitypub/#outbox">Outbox</a> exists and can activities can be POSTed to it - <a href="/activitypub/outbox">/activitypub/outbox</a></li>
								</ul>
							</li>
						</ul>
				`)
				// create new
				res.write(`
					<h2>Post a Note</h2>
					<form method="post">
						<textarea name="content"></textarea>
						<input type="submit" value="post" />
					</form>
				`)
				// recent
				res.write(`
					<h2>Public Activity</h2>
					<pre>${
						// #TODO: discover /public url via HATEOAS
						await readableToString(await sendRequest(http.request(apiUrl+'/activitypub/public')))
					}</pre>
				`)
				// show other links
				res.write(`
					<h2>More Info/Links</h2>
					<pre>${
						await readableToString(await sendRequest(http.request(apiUrl)))
					}</pre>
				`)				
				res.end()
				return;			
			case 'post':
				const submission = await readableToString(req);
				// assuming application/x-www-form-urlencoded
				const { content } = querystring.parse(submission);
				// don't allow HTML
				const safeContent = escape(content);
				const note = {
				  '@context': 'https://www.w3.org/ns/activitypub',
				  'type': 'Note',
				  'content': safeContent,
				}
				// submit to outbox
				// #TODO is it more 'precise' to convert this to an activity here?
				// #TODO discover outbox URL
				const postToOutboxRequest = http.request(Object.assign(url.parse(apiUrl+'/activitypub/outbox'), {
					headers: {
			      'content-type': 'application/ld+json; profile="https://www.w3.org/ns/activitystreams#"'
					},
					method: 'post',
					path: '/activitypub/outbox'
				}));
				postToOutboxRequest.write(JSON.stringify(note));
				const postToOutboxResponse = await sendRequest(postToOutboxRequest);
				// handle form submission by posting to outbox
				res.writeHead(302, { location: req.url })
				res.end()
		}
	}
}


async function readableToString (readable) {
  let body = ''
  return new Promise((resolve, reject) => {
    readable.on('error', reject)
    readable.on('data', (chunk) => {
      body += chunk
      return body
    })
    readable.on('end', () => resolve(body))
  })
}

async function sendRequest (request) {
  return new Promise((resolve, reject) => {
    request.once('response', resolve)
    request.once('error', reject)
    request.end()
  })
}